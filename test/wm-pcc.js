'use strict';

// FIXME the Polymer element methods are not tested

require('./gerrit-mocks.js');

const wmPcc = require('../plugins/wm-pcc.js');

QUnit.module( '[wm-pcc]', () => {

  QUnit.module('PCCProvider', () => {

    QUnit.module('isLegacyMessage()', () => {
      QUnit.test( 'false without message', assert => {
        assert.false(
          wmPcc.PCCProvider.isLegacyMessage( { // ChangeMessageInfo
            message: '',
          })
        );
      });

      QUnit.test( 'unttaged PCC messages', assert => {
        assert.true(
          wmPcc.PCCProvider.isLegacyMessage( { // ChangeMessage
            message: 'Patch Set 1: Verified+1\n\nPCC SUCCESS (NOOP 4): http://xxx',
          })
        );
      });

      QUnit.test( 'handles non PCC messages', assert => {
        assert.false(
          wmPcc.PCCProvider.isLegacyMessage( { // ChangeMessage
            message: 'hello',
          })
        );
      });
    } ); // isLegacyMessage()

    QUnit.module('isUtilsPccReport()', () => {
      QUnit.test( 'isUtilsPccReport() tagged messages', assert => {
        assert.true(
          wmPcc.PCCProvider.isUtilsPccReport( { // ChangeMessage
            tag: 'autogenerated:pcc-py',
          })
        );
      });
    } ); // isUtilsPccReport()

    QUnit.module('isCIReport()', () => {
      QUnit.test( 'recognizes Zuul experimental', assert => {
        assert.true(
          wmPcc.PCCProvider.isCIReport( { // ChangeMessage
            tag: 'autogenerated:ci-experimental',
            author: {
              name: 'jenkins-bot',
            }
          })
        );
      });
    } ); // isCIReport()

    QUnit.module('buildsFromMessage()', () => {
      QUnit.test( 'message from utils/pcc --post-crash', assert => {
        assert.propContains(
          wmPcc.PCCProvider.buildsFromMessage(
            'Patch Set 1: Verified-1\n\nPCC Check manually: xxxYY'
          )[0],
          { consoleUrl: 'xxxYY' }
        );
      });

      QUnit.test( 'multiple jobs', assert => {
        const builds = wmPcc.PCCProvider.buildsFromMessage(
          'Patch Set 2:\n\nExperimental build failed.\n\n' +
          '- https://integration.wikimedia.org/ci/job/job1/3118/console : SUCCESS in 36s\n' +
          '- https://integration.wikimedia.org/ci/job/job2/604/console : FAILURE in 23s (non-voting)\n'
        );
        assert.strictEqual( builds.length, 2, 'Found two jobs' );
        assert.propContains( builds[0], { buildNumber: 3118 } );
        assert.propContains( builds[1], { buildNumber: 604 } );
      });

      QUnit.test( 'message with user comment', assert => {
        // Seen on https://gerrit.wikimedia.org/r/c/operations/puppet/+/901612
        // which had a draft comment submitted by the pcc.py script.
        const consoleUrl = 'https://integration.wikimedia.org/ci/job/somejob/99/console';
        assert.propContains(
          wmPcc.PCCProvider.buildsFromMessage(
            `Patch Set 3: Verified+1\n\n(1 comment)\n\nPCC SUCCESS (): ${consoleUrl}`
          )[0],
          {
            consoleUrl: consoleUrl,
            jobName: 'somejob',
            buildNumber: 99,
            result: 'SUCCESS',
            voting: true,
          }
        );
      });

      QUnit.test( 'extracts matrix job label', assert => {
        // Seen on https://gerrit.wikimedia.org/r/c/operations/puppet/+/901612
        // which had a draft comment submitted by the pcc.py script.
        const consoleUrl = 'https://integration.wikimedia.org/ci/job/matrixjob/label=somenode/99/console';
        assert.propContains(
          wmPcc.PCCProvider.buildsFromMessage(
            `Patch Set 3: Verified+1\n\n(1 comment)\n\nPCC SUCCESS (): ${consoleUrl}`
          )[0],
          {
            jobName: 'matrixjob',
            label: 'somenode',
            buildNumber: 99,
          }
        );
      });
    } ); // buildsFromMessage()

    QUnit.module('parse()', hooks => {
      const consoleUrl = 'https://integration.wikimedia.org/ci/job/somejob/99/console';
      const changeData = {
        changeNumber: 1042,
        patchsetNumber: 9,
      };
      let pccProvider;

      hooks.before( () => {
        pccProvider = new wmPcc.PCCProvider();
      });

      QUnit.test( 'returns undefined for other messages', assert => {
        assert.strictEqual(
          pccProvider.parse( { message: '' }, {} ),
          undefined
        );
      });

      QUnit.test( 'injects Jenkins build number', assert => {
        const checkRuns = pccProvider.parse(
          { // ChangeMessageInfo
            tag: 'autogenerated:ci-experimental',
            author: {
              name: 'jenkins-bot',
            },
            message: `PCC SUCCESS (): ${consoleUrl}`,
          },
          changeData
        );
        assert.strictEqual( checkRuns[0].results[0].jenkinsBuildNumber, 99 );
      });

      QUnit.test( 'injects change data', assert => {
        const checkRuns = pccProvider.parse(
          { // ChangeMessageInfo
            tag: 'autogenerated:ci-experimental',
            author: {
              name: 'jenkins-bot',
            },
            message: `PCC SUCCESS (): ${consoleUrl}`,
          },
          changeData
        );
        assert.deepEqual( checkRuns[0].results[0].change, changeData );
      });
    } ); // parse()

    QUnit.module('setBuildPuppetVersion()', () => {
      const matrixJobTestCases = {
        'Puppet 5 label': [ 'puppet5-compiler-node', 5 ],
        'Puppet 7 label': [ 'puppet7-compiler-node', 7 ],
        'Other labels': [ 'whatever', undefined ],
      };

      QUnit.test.each( 'matrix job', matrixJobTestCases,
        ( assert, [ label, expectedPuppetVersion ] ) => {
          const build = { label: label };
          wmPcc.PCCProvider.setBuildPuppetVersion( build );
          assert.strictEqual( build.puppetVersion, expectedPuppetVersion );
        }
      );

      const FreestyleJobTestCases = {
        'compiler-test': [ 'operations-puppet-catalog-compiler-test', 5 ],
        'compiler-puppet7-test': [ 'operations-puppet-catalog-compiler-puppet7-test', 7 ],
        'other job': [ 'some-job', undefined ],
      };

      QUnit.test.each( 'freestyle job', FreestyleJobTestCases,
        ( assert, [ jobName, expectedPuppetVersion ] ) => {
          const build = { jobName: jobName };
          wmPcc.PCCProvider.setBuildPuppetVersion( build );
          assert.strictEqual( build.puppetVersion, expectedPuppetVersion );
        }
      );

    } ); // setBuildPuppetVersion()

    const getBuildCategoryTestCases = {
      default: [ {}, 'WARNING' ],
      'success is INFO': [ { result: 'SUCCESS' }, 'INFO' ],
      'non success voting is ERROR': [ { result: 'UNSTABLE', voting: true }, 'ERROR' ],
      'non success non voting is WARNING': [ { result: 'UNSTABLE', voting: false }, 'WARNING' ],
    };

    QUnit.test.each( 'getBuildCategory()', getBuildCategoryTestCases,
      ( assert, [ build, expectedCategory ] ) => {
        assert.strictEqual(
          wmPcc.PCCProvider.getBuildCategory( build ),
          expectedCategory
        );
      }
    );

    QUnit.module( 'fetch()', hooks => {
      let provider;
      hooks.before( () => {
        provider = new wmPcc.PCCProvider();
      });

      QUnit.test( 'emptyResponse when there are no messages', async assert => {
        const response = await provider.fetch(
          { // ChangeData
            changeInfo: {
              project: 'operations/puppet',
              messages: [],
            }
          }
        );
        assert.propContains(response, { responseCode: 'OK' } );
        assert.deepEqual(response.runs.filter( run => run.status !== 'RUNNABLE' ), []);
      });

      QUnit.test( 'emptyResponse has a runnable action', async assert => {
        const response = await provider.fetch(
          { // ChangeData
            changeInfo: {
              project: 'operations/puppet',
              messages: [],
            }
          }
        );
        assert.propContains(response.runs[0], {
          checkName: 'Puppet Compiler [CI]',
          status: 'RUNNABLE',
        });
        assert.propContains(response.actions[0], {
          name: 'Run Puppet Compiler',
          summary: true,
        });
      });

      QUnit.test( 'full response', async assert => {
        const response = await provider.fetch(
          { // ChangeData
            changeNumber: 999,
            changeInfo: {
              project: 'operations/puppet',
              messages: [
                {
                  author: {
                    name: 'jenkins-bot',
                  },
                  tag: 'autogenerated:ci-experimental',
                  message: [
                    'Patch Set 13:',
                    '',
                    'Experimental build succeeded.',
                    '',
                    '- https://integration.wikimedia.org/ci/job/operations-puppet-catalog-compiler-test/2624/console : SUCCESS in 52s',
                    '- https://integration.wikimedia.org/ci/job/operations-puppet-catalog-compiler-puppet7-test/112/console : SUCCESS in 28s (non-voting)'
                  ].join('\n'),
                },
                {
                  author: {
                    name: 'johndoe',
                  },
                  message: [
                    'Patch Set 16: Verified+1',
                    '',
                    'PCC SUCCESS (CORE_DIFF 1): https://integration.wikimedia.org/ci/job/operations-puppet-catalog-compiler/label=puppet5-compiler-node/389/console'
                  ].join('\n'),
                },
              ]
            }
          }
        );

        assert.propContains(response, { responseCode: 'OK' } );
        assert.strictEqual( response.runs.length, 3 );

        assert.strictEqual( response.runs[0].checkName, 'Puppet Compiler v5 [CI]' );
        assert.strictEqual( response.runs[0].results.length, 1 );
        assert.strictEqual( response.runs[0].results[0].summary, 'Puppet 5 [trigger: CI]' );

        assert.strictEqual( response.runs[1].checkName, 'Puppet Compiler v7 [CI]' );
        assert.strictEqual( response.runs[1].results.length, 1 );
        assert.strictEqual( response.runs[1].results[0].summary, 'Puppet 7 [trigger: CI]' );

        assert.strictEqual( response.runs[2].checkName, 'Puppet Compiler [utils/pcc]' );
        assert.strictEqual( response.runs[2].results.length, 1 );
        assert.strictEqual( response.runs[2].results[0].summary, 'Puppet 5 [trigger: utils/pcc]' );

      } );

    } );

  } ); // PCCProvider

} );
