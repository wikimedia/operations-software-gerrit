'use strict';

/* eslint-disable max-len */
/**
 * @typedef { import("@gerritcodereview/typescript-api/checks").Category } Category
 * @typedef { import("@gerritcodereview/typescript-api/checks").ChangeData } ChangeData
 * @typedef { import("@gerritcodereview/typescript-api/checks").CheckResult } CheckResult
 * @typedef { import("@gerritcodereview/typescript-api/checks").CheckRun } CheckRun
 * @typedef { import("@gerritcodereview/typescript-api/checks").ChecksProvider } ChecksProvider
 * @typedef { import("@gerritcodereview/typescript-api/checks").FetchResponse } FetchResponse
 * @typedef { import("@gerritcodereview/typescript-api/checks").Link } Link
 * @typedef { import("@gerritcodereview/typescript-api/checks").ResponseCode } ResponseCode
 * @typedef { import("@gerritcodereview/typescript-api/checks").RunStatus } RunStatus
 * @typedef { import("@gerritcodereview/typescript-api/checks").Tag } Tag
 * @typedef { import("@gerritcodereview/typescript-api/checks").TagColor } TagColor
 * @typedef { import("@gerritcodereview/typescript-api/rest-api").ChangeMessageInfo } ChangeMessageInfo
 */

/**
 * Process messages from our Puppet Catalog Compiler
 *
 * The compilation is triggered either by commentting `check experimental` on a
 * Gerrit change or by manually running `utils/pcc` from
 * `operations/puppet.git` which triggers a Jenkins job.
 *
 * The builds outputs are at https://puppet-compiler.wmflabs.org/output/
 *
 * @implements {ChecksProvider}
 *
 * Define a type which extends CheckResult. We need the change and jenkins
 * build number when formatting the detailled result:
 *
 * @typedef {Object} PCCProperties
 * @property {ChangeData} change
 * @property {number} jenkinsBuildNumber
 *
 * @typedef {CheckResult & PCCProperties} AugmentedCheckResult
 */
class PCCProvider {

  constructor() {
    /** @type {Object.<string, number>} */
    this.attempt = {};
    this.resetAttempt();
  }

  resetAttempt() {
    this.attempt = {};
  }

  /**
   * Historical untagged messages from `utils/pcc`
   *
   * @param {ChangeMessageInfo} changeMessage
   * @return {boolean} Whether the message is an untagged PCC comment
   */
  static isLegacyMessage(changeMessage) {
    const message = changeMessage.message.split('\n')[2];
    if (typeof message === 'undefined') {
      return false;
    }
    return (
      message.startsWith('PCC SUCCESS (') ||
      message.startsWith('PCC FAIL (') ||
      message.startsWith('PCC Check manually: ')
    );
  }

  /**
   * Message posted from Puppet.git `utils/pcc`
   *
   * Users can trigger the build via `operations/puppet.git` script
   * `utils/pcc.py` which reports back as their own user rather than a service
   * user.
   * Since 2022-12-14, the comments are tagged autogenerated:pcc-py
   * I587381f3910a56441805c2544e8b09d936cdd868
   *
   * @param {ChangeMessageInfo} changeMessage
   * @return {boolean} Whether the message comes from utils/pcc
   */
  static isUtilsPccReport(changeMessage) {
    return (
      typeof changeMessage.tag !== 'undefined' && // for tests not defining tag
      changeMessage.tag.startsWith('autogenerated:pcc-py')
    ) || (
      PCCProvider.isLegacyMessage(changeMessage)
    );
  }

  /**
   * Message reported by Zuul via `check experimental`
   *
   * @param {ChangeMessageInfo} changeMessage
   * @return {boolean} Whether the message comes from Zuul/Jenkins
   */
  static isCIReport(changeMessage) {
    return (
      typeof changeMessage.tag !== 'undefined' &&
        changeMessage.tag.startsWith('autogenerated:ci-experimental') &&
        changeMessage.author && changeMessage.author.name === 'jenkins-bot'
    );
  }

  /**
   * @param {ChangeMessageInfo} changeMessage
   * @param {ChangeData} change
   * @return {CheckRun}
   */
  parse(changeMessage, change) {
    if ( !PCCProvider.isUtilsPccReport(changeMessage) &&
      !PCCProvider.isCIReport(changeMessage)
    ) {
      return undefined;
    }

    const trigger = PCCProvider.isCIReport(changeMessage) ? 'CI' : 'utils/pcc';
    const jenkinsBuilds = PCCProvider.buildsFromMessage(changeMessage.message);
    const checkResults = jenkinsBuilds.map(
      build => {
        /** @type {AugmentedCheckResult} */
        const checkResult = {
          externalId: `${build.jobName}#${build.buildNumber}`,
          category: PCCProvider.getBuildCategory( build ),
          summary: `Puppet ${build.puppetVersion} [trigger: ${trigger}]`,
          jenkinsBuildNumber: build.buildNumber,
          // A dummy message which enables the expansion logic
          message: 'Click to load details',
          links: [
            /** @type {Link} */
            ({
              url: `https://puppet-compiler.wmflabs.org/output/${change.changeNumber}/${build.buildNumber}`,
              primary: true,
              icon: 'external',
              tooltip: 'Go to PCC build output',
            }),
            /** @type {Link} */
            ({
              url: build.consoleUrl,
              primary: true,
              icon: 'external',
              tooltip: 'Go to Jenkins console',
            }),
          ],
          tags: [
            /** @type {Tag} */ ({
              name: 'Puppet ' + build.puppetVersion,
              color: /** @type {TagColor} */ (build.puppetVersion === 5 ? 'yellow' : 'pink'),
            }),
            /** @type {Tag} */ ({
              name: trigger,
              color: 'gray',
            }),
          ],
          change: change,
        };
        return checkResult;
      }
    );

    const checkName = `Puppet Compiler [${trigger}]`;
    if ( typeof this.attempt[checkName] === 'undefined' ) {
      this.attempt[checkName] = 1;
    } else {
      this.attempt[checkName] += 1;
    }

    /** @type {CheckRun} */
    const checkRun = {
      checkName: checkName,
      attempt: this.attempt[checkName],
      status: /** @type {RunStatus} */ ('COMPLETED'),
      results: checkResults,
    };

    return checkRun;
  }

  /**
   * @typedef JenkinsBuild
   * @property {string} consoleUrl
   * @property {string} jobName
   * @property {string} label
   * @property {number} buildNumber
   * @property {string} result Build result reported by Jenkins
   * @property {string} spent Time spent running the build
   * @property {boolean} voting Whether the job is voting in Zuul
   * @property {number} [puppetVersion] Set by setBuildPuppetVersion()
   *
   * @param {ChangeMessageInfo["message"]} message
   * @return {JenkinsBuild[]} Jenkins build number, undefined when none can be found
   */
  static buildsFromMessage(message) {
    // Handle report from `utils/pcc --post-crash`
    const postCrash = /PCC Check manually: (?<buildUrl>.+)/.exec(message);
    if (postCrash) {
      return [
        /** @type {JenkinsBuild } */
        {
          consoleUrl: postCrash.groups.buildUrl,
          jobName: undefined,
          label: undefined,
          buildNumber: undefined,
          result: undefined,
          spent: undefined,
          voting: undefined,
          puppetVersion: undefined,
        }
      ];
    }

    // TODO capture the node status for the build summary?
    //
    // Previously we had:
    //   /PCC (?<result>SUCCESS|FAIL) \((?<nodeStatus>.*?)\): (?<consoleUrl>.+)/
    //                                ^^^^^^^^^^^^^^^^^^^^^^^
    //
    const reBuildUrl = /(PCC (?<pccResult>SUCCESS|FAIL).*)?(?<consoleUrl>https:\/\/integration.wikimedia.org\/ci\/job\/(?<jobName>[^\/]+)\/(label=(?<label>[^\/]+)\/)?(?<buildNumber>\d+)\/console)(?: : (?<result>[A-Z_]+))?(?: in (?<spent>.*?))?(?<nonvoting> \(non-voting\))?$/gm;
    const builds = [];
    let match;
    while ( (match = reBuildUrl.exec( message )) !== null) {
      /** @type {JenkinsBuild } */
      const build = {
        consoleUrl: match.groups.consoleUrl,
        jobName: match.groups.jobName,
        label: match.groups.label,
        buildNumber: Number(match.groups.buildNumber),
        result: (typeof match.groups.pccResult !== 'undefined') ? match.groups.pccResult : match.groups.result,
        spent: match.groups.spent,
        voting: typeof match.groups.nonvoting === 'undefined',
      };
      PCCProvider.setBuildPuppetVersion( build );
      builds.push( build );
    }
    return builds;
  }

  /**
   * Alter a {JenkinsBuild} to populate the Puppet version used
   *
   * @param {JenkinsBuild} build
   * @return {void} Set puppetVersion property on the given build.
   */
  static setBuildPuppetVersion( build ) {
    if ( typeof build.label !== 'undefined' ) {
      let m;
      if (m = build.label.match(/puppet(?<version>\d+)-compiler-node/) ) {
        build.puppetVersion = Number(m.groups.version);
      }
    } else {
      if ( build.jobName === 'operations-puppet-catalog-compiler-test' ) {
        build.puppetVersion = 5;
      } else if ( build.jobName === 'operations-puppet-catalog-compiler-puppet7-test' ) {
        build.puppetVersion = 7;
      }
    }
  }

  /**
   * @param {JenkinsBuild} build
   * @return {Category} CheckResult category based on the build status and whether it is voting
   */
  static getBuildCategory(build) {
    let category;
    switch (build.result) {
    case 'SUCCESS':
      category = /** @type {Category} */ ('INFO');
      break;
    default:
      category = /** @type {Category} */ (build.voting ? 'ERROR' : 'WARNING');
    }
    return category;
  }

  /**
   *
   * @param {ChangeData} change
   * @return {Promise<FetchResponse>}
   */
  async fetch(change) {

    // Since we reprocess all messages
    this.resetAttempt();

    /** @type {CheckRun[]} */
    const checkRuns = change.changeInfo.messages.filter(
      // UI focuses on the latest patchset by default and a drowpdown lets one
      // browse runs from previous patchset which will invoke fetch() again
      // with a different ChangeData.patchsetNumber.
      m => m._revision_number === change.patchsetNumber
    ).map(
      m => this.parse(m, change)
    ).filter( notUndefined => notUndefined );

    /** @type {FetchResponse} */
    const response = {
      responseCode: /** @type {ResponseCode} */ ('OK'),
      runs: checkRuns,
    };
    return response;
  }
}

/**
 * @typedef {Object} PCCBuildState
 * @property {string} description
 * @property {Array<string>} hosts
 */
/**
 * @typedef {Object} PCCBuild
 * @property {string} puppet_version
 * @property {string} job_id
 * @property {string} change_id
 * @property {Array<string>} hosts
 * @property {Object<string,PCCBuildState>} states
 */

class PCCBuildResultElement extends Polymer.Element {
  static get is() { return 'pcc-build-result'; }

  static get properties() {
    return {
      buildJson: {
        type: Object,
        readOnly: true,
      },
      result: {
        observer: '_onResultChanged',
      },
      states: {
        type: Array,
        computed: '_computeBuildStates(buildJson.states)',
      },
    };
  }

  static get template() {
    return Polymer.html`
    <style>
      a {
        color: var(--link-color);
        text-decoration: none;
      }
      ul {
        margin: 0;
        padding-inline-start: 1em;
        max-height: 12em;
        overflow-y: auto;
      }
      .err, .error, .fail, .cancelled {
          color: red;
      }
      .noop {
          color: darkgreen;
      }
      .diff, .core_diff {
          color: darkgoldenrod;
      }
    </style>
    <div>
      <div id=summary>
        <span>Puppet:<b>[[buildJson.puppet_version]]</b></span>
        <span>States:<b>[[_computeStatesSummary(buildJson.states)]]</b></span>
        <span>Hosts selection:<b>[[buildJson.hosts]]</b></span>
      </div>
      <template is="dom-repeat" items="[[states]]" as="state">
        <hr/>
        [[state.hosts.length]] hosts
        <b class$="[[state.stateName]]">[[state.stateName]]</b>
        [[state.description]]
        <ul>
          <template is="dom-repeat" items="[[state.hosts]]" as="host">
            <li><a target="_blank" href$="[[_outputUrl(result, host)]]">[[host]]</a></li>
          </template>
        </ul>
      </template>
    </div>
    `;
  }

  /**
   * @param {AugmentedCheckResult} result
   * @param {string} path Path relative to the PPC output URL
   * @return {string} Full URL to the output page for this change and Jenkins build
   */
  _outputUrl(result, path = '') {
    return 'https://puppet-compiler.wmflabs.org/output' +
      `/${result.change.changeNumber}` +
      `/${result.jenkinsBuildNumber}` +
      `/${path}`;
  }

  /**
   * @param {PCCBuild["states"]} buildStates
   * @return {string}
   */
  _computeStatesSummary(buildStates) {
    const ret = [];
    for (const [ stateName, details ] of Object.entries(buildStates) ) {
      ret.push(`${stateName}: ${details.hosts.length}`);
    }
    return ret.join(', ');
  }

  /**
   * @param {AugmentedCheckResult} newResult
   * @param {AugmentedCheckResult} oldResult
   */
  _onResultChanged(newResult, oldResult) {
    if ( JSON.stringify(newResult) === JSON.stringify(oldResult) ) {
      // result got updated with no change, skip fetch
      return;
    }

    const buildUrl = this._outputUrl(newResult, 'build.json');
    fetch( buildUrl )
      .then( resp => {
        if ( !resp.ok ) {
          console.warn('Failed to fetch', buildUrl);
          return;
        }
        return resp.json();
      } )
      .then( json => {
        // @ts-ignore
        this._setBuildJson(json);
      } );
  }

  /**
   * @param {PCCBuild} buildJsonStates
   * @return {Object}
   */
  _computeBuildStates(buildJsonStates) {
    return Object.entries(buildJsonStates).map(
      ([ stateName, details ]) => {
        return {
          ...{ stateName: stateName },
          .../** @type {Object} */(details),
        };
      }
    );
  }
}

customElements.define(PCCBuildResultElement.is, PCCBuildResultElement);

window.Gerrit.install(plugin => {
  plugin.registerCustomComponent(
    'check-result-expanded',
    PCCBuildResultElement.is,
    // Once expanded, replace the existing "Click to load details" message
    { replace: true },
  );
  plugin.checks().register(
    new PCCProvider(),
    {
      fetchPollingIntervalSeconds: 600,
    }
  );
});

if ( typeof module !== 'undefined' ) {
  // eslint-disable-next-line no-undef
  module.exports = {
    PCCProvider: PCCProvider,
  };
}
